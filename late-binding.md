### Late binding

#### [Alan Kay at OOPSLA 1997](http://www.youtube.com/watch?v=oKg1hTOQXoY&t=45m54s)  

So let me ask a question. I won't take names. But how many people here still use a language that essentially forces you—and the development system forces you to develop outside of the language; compile and reload, and go, even if it's fast, like Visual Café.—How many here still do that? Let's just see. Come on. Admit it! We can have a Texas tent beating later. [Smiles] [Laughter] That cannot possibly be other than a dead end for building complex systems, where much of the building of complex systems is in part going to go into trying to understand what the possibilities for interoperability is with things that already exist. I just played a very minor part in the design of the ARPANET. I was one of thirty graduate students who went to systems design meetings to try and formulate design principles for the ARPANET, also about thirty years ago. The ARPNANET, of course, became the Internet, and from the time it started running—just around 1969 or so—to this day, it has expanded by about a factor of a hundred million. That's pretty good. Eight orders of magnitude. I talked to Larry Roberts about this the other day. There is not one physical atom in the Internet today, that was in the original ARPANET. There is not one line of code in the Internet today that was in the original ARPANET. Of course, if we had IBM main frames in the original ARPANET, that wouldn't have been true. This is a system that has expanded by a hundred million, has changed every atom and every bit, and has never had to stop. That is the metaphor we absolutely must apply to what we think are smaller things. When we think programming is small, that's why your programs are so big. That's why they become pyramids instead of gothic cathedrals.

#### [Stanford EE 380 class by Allison, Wharton](https://www.youtube.com/watch?v=G8X-yvDWClc)  

At some point we are no longer going to be able to construct software systems ourselves. People were starting to realize that on the timesharing system that it would be really dumb to take timesharing system down to make a change in it, because all the great tools are on the timesharing system. So how can you change timesharing OS? The answer is - late binding. Late binding is in a sense what this talk is about. I try to impress on you the idea how important it is that beyond certain point you just never want to stop a system. Systems cannot be fixed like clocks. They are negotiated with. You want the integrity of the system. Of course, the Internet has provided interesting example of a system that from just a few separate principles has not a single atom as far as can tell ... we just did a survey couple of weeks ago among people who worked on it ... As far as anybody can tell there is no a single atom of physical equipment that existed in the ARPANET that is now in the Internet, even in the phone system. And yet it is never stop running since the late 60s. It has continuously replaced itself and grown, and new things were done on it. And why not recapitulate what the Internet is in a software system, if you just think about what it is. If the Internet could do it, surely you can do it on the single machine. 

The more trouble you get into as a programmer, the more you start appreciate late binding, the more you start appreciating getting the thing running regardless of how fast it runs.

#### [Alan Kay at MIT-EECS 1998 Fall Semester Colloquium Series](http://www.youtube.com/watch?v=BUud1gcbS9k&t=33m56s)
If you extend complexity far enough, at some point we'll have to start growing software, that is we won't ... like in the simplest case we won't want to ever build a system from compiling word processor files and making a load module. Most people
would love not to do that anyway, because as you get more and more complex just things like the initialization problems and getting everything set up and linked together is such an incredible thing you really want to start with something that's already working and just make it incredibly better over and over again.

#### [Evolvability and modifiability of code](https://www.youtube.com/watch?v=O3tVctB_VSU)
The other thing that seems really important to me is that we spend all our time modifiying our existing code. The problem is that our code is not adequately evolvable and modifiable to fit the future. In fact, what we want is to make systems that have the property that they are good for things that the designer did not even think of or intend. That is a big problem. That is a real problem I want to go after a little bit. The problem is that when we build systems we program ourselves into holes. I have done it a number of times. I have been programming since 1961, and found more ways to screw up that anybody I know. I learned a lot I hope but not an infinite amount. So here is this problem. How do we keep ourselves from programming ourselves into holes? What does that mean? It means that we make decisions early into some process that spread all over our system. The consequences of those decisions are such that the things we want to change later are difficult to change because we have to change very large amount of stuff. That is the problem. I want to figure out ways we can organize systems so that the consequences of the decisions we make are not expensive to change. We cannot avoid making decisions, but we can try to figure out ways to minimize the cost of changing decisions we made.
