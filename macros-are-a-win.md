#### Macros are a win

Scott McKay at [Dynamic Languages Panel (on runtime)](https://www.youtube.com/watch?v=SjbtEnfm7_Q): Syntactic abstraction is the key to reducing the complexity of code, and nobody has caught on to hygenic macros. It is time for that to change. It super important. I cannot say anything about the implementation technology that I am using at my company or someone will shoot me. I have some apples to apples comparison showing an expansion of code of 24x for the same code between some other language and Java. My worst case nightmare scenario was an explosion of 10x, so I was not even close. And it is all due to the syntactic abstraction that this other language provides. 

Richard Kelsey at [Dynamic Languages Panel (on runtime)](https://www.youtube.com/watch?v=SjbtEnfm7_Q): I have to say that I have caught on to hygenic macros, so somebody has.

Will Clinger at [Dynamic Languages Panel (on compilation)](https://www.youtube.com/watch?v=wbEMFMioLto): I found easier to list bad ideas that haven't been dropped, but whose time has nonetheless passed. Finalizers, for instance. On Sunday night a friend was telling me that C++ was much better than Java for his application becaues he could not predict when the Java finalizer would run. I asked him, why don't you just call pseudo destructor method explicitly whenever the relevant object goes out of scope. He said, it is hairy in the presence of exceptions and some programmers are bound to get it wrong or not do it at all. Ok, why not to make it impossible to create these objects except by using a macro that generates finalization code automatically. He said, Java does not have macros. He had a point. I think programming language designers have been avoiding macros becaue they hate C macros. Well, C macros ought to be hated, but designers have drawn wrong conclusions from their badness. As bad as they are, programmers use them. Why? Because they serve a purpose. Language designers should not be so arrogant as to think that their language is so much better than C that no project will ever need syntactic abstraction that designer failed to anticipate. Hygenic macros are a major win.

[Why important it is for language to have macros? Is it a niciety or an essential feature if you want to grow the language?](http://www.youtube.com/watch?v=agw-wlHGi0E&t=1h14m25s)  
Paul Graham: For me personally, I cannot program in a language that does not have macros. I just cannot make myself do it. I end up doing outrageous things, like going to work for any company that will hire me to use macros. If they seem like they are going to go out of business, start a company myself, so that I can program in Lisp.  
Guy Steele: For the languages that do no have macros I find myself in effect use them in my pseudo-code and then hand-expanding them, and as a result getting code that might be somewhat less maintainable because some of the abstractions are not apparent any more.  
Jonathan Reese: I write a preprocessor for the language that does not have macros. Not necessarily implementing macros, but doing what I want for particular application. 

[Vladimir Sedach](https://news.ycombinator.com/item?id=645338)  
I used to like arguing over the Internet about this subject. There are many good technical and management/organizational arguments you can make for and against macros. What I've come to realize is they're all pretty much irrelevant.
The entire point of programming is automation. The question that immediately comes to mind after you learn this fact is - why not program a computer to program itself? Macros are a simple mechanism for generating code, in other words, automating programming. Unless your system includes a better mechanism for automating programming (so far, I have not seen any such mechanisms), _not_ having macros means that you basically don't understand _why_ you are writing code.

This is why it is not surprising that most software sucks - a lot of programmers only have a very shallow understanding of why they are programming. Even many hackers just hack because it's fun. So is masturbation.

This is also the reason why functional programming languages ignore macros. The people behind them are not interested in programming automation. Wadler created ML to help automate proofs. The Haskell gang is primarily interested in advancing applied type theory.

Which brings me to my last point: as you probably know, the reputation of the functional programming people as intelligent is not baseless. You don't need macros if you know what you are doing (your domain), and your system is already targeted at your domain. Adding macros to ML will have no impact on its usefulness for building theorem provers. You can't make APL or Matlab better languages for working with arrays by adding macros. But as soon as you need to express new domain concepts in a language that does not natively support them, macros become essential to maintaining good, concise code. This IMO is the largest missing piece in most projects based around domain-driven design.
